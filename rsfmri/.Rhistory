pc1 <- mat
table <- tibble(subject = sub,
scan = 1:209,
timeseries = pc1,
roi = roi,
network = network,
network_name = network_name)
if (is.null(roidata)) {
roidata <- table
} else {
roidata %<>% bind_rows(table)
}
}
# Pivot long data format into wide data
wroidata <- roidata %>% pivot_wider(id_cols = scan,
names_from = roi,
values_from = timeseries)
X  <- as.matrix(wroidata[,2:265])/1000
PR <- pcor(X)$estimate
R  <- cor(X)
# Generate matrices:
# The partial correlation matrix
long_pr <- melt(PR)
pdf(paste(sub, "fc_pcorr.pdf", sep="/"))
ggplot(long_pr, aes(x=Var1, y=Var2)) +
geom_raster(aes(fill=value)) +
scale_fill_gradient2(limits=c(-1,1), low = "blue", high = "red", mid = "white") +
theme_pander() +
ggtitle(paste(sub, ": Functional Connectivity (Partial Correlations)", sep="")) +
xlab("ROIs") +
ylab("ROIs")
dev.off()
write.table(PR, col.names = T,
row.names = T,
file = paste(sub, "PR.txt", sep="/"))
# The standard correlation matrix
long_r <- melt(R)
pdf(paste(sub, "fc_corr.pdf", sep="/"))
ggplot(long_r, aes(x=Var1, y=Var2)) +
geom_raster(aes(fill=value)) +
scale_fill_gradient2(limits=c(-1,1), low = "blue", high = "red", mid = "white") +
theme_pander() +
ggtitle(paste(sub, ": Functional Connectivity, Standard Correlations)", sep="")) +
xlab("ROIs") +
ylab("ROIs")
dev.off()
write.table(R, col.names = T,
row.names = T,
file = paste(sub, "R.txt", sep="/"))
}
write.table(PR, col.names = T,
row.names = T,
file = paste(sub, "PR.txt", sep="/"))
power2011 <- read_csv("bin/power_2011.csv",
col_types = cols(ROI=col_double(),
X = col_double(),
Y = col_double(),
Z = col_double(),
Network = col_double(),
Color = col_character(),
NetworkName = col_character())) %>%
dplyr::select(ROI, X, Y, Z, Network, Color, NetworkName)
filenames <- paste("region_",
sprintf("%03d", power2011$ROI),
"_network_",
sprintf("%03d", max(0, power2011$Network)),
".txt",
sep="")
for (sub in dir()[grep("sub-*", dir())]) {
roidata <- NULL
print(sub)
for (roi in power2011$ROI) {
#print(roi)
network <- power2011 %>%
filter(ROI == roi) %>%
dplyr::select(Network) %>%
as.numeric()
network_name <- power2011 %>%
filter(ROI == roi) %>%
dplyr::select(NetworkName) %>%
as.character()
file_name <- paste("region_",
sprintf("%03d", roi),
"_network_",
sprintf("%02d", max(0, network)),
".txt",
sep="")
#mat <- t(read.table(paste(sub, "func", file_name, sep="/")))
#pc1 <- prcomp(mat)  #PCA
#pc1 <- pc1$x[,1]    # first PC
mat <- colMeans(read.table(paste(sub, "func", file_name, sep="/")))
pc1 <- mat
table <- tibble(subject = sub,
scan = 1:209,
timeseries = pc1,
roi = roi,
network = network,
network_name = network_name)
if (is.null(roidata)) {
roidata <- table
} else {
roidata %<>% bind_rows(table)
}
}
# Pivot long data format into wide data
wroidata <- roidata %>% pivot_wider(id_cols = scan,
names_from = roi,
values_from = timeseries)
X  <- as.matrix(wroidata[,2:265])/1000
PR <- pcor(X)$estimate
R  <- cor(X)
# Generate matrices:
# The partial correlation matrix
long_pr <- melt(PR)
pdf(paste(sub, "fc_pcorr.pdf", sep="/"))
ggplot(long_pr, aes(x=Var1, y=Var2)) +
geom_raster(aes(fill=value)) +
scale_fill_gradient2(limits=c(-1,1), low = "blue", high = "red", mid = "white") +
theme_pander() +
ggtitle(paste(sub, ": Functional Connectivity (Partial Correlations)", sep="")) +
xlab("ROIs") +
ylab("ROIs")
dev.off()
write.table(PR, col.names = T,
row.names = T,
file = paste(sub, "PR.txt", sep="/"))
# The standard correlation matrix
long_r <- melt(R)
pdf(paste(sub, "fc_corr.pdf", sep="/"))
ggplot(long_r, aes(x=Var1, y=Var2)) +
geom_raster(aes(fill=value)) +
scale_fill_gradient2(limits=c(-1,1), low = "blue", high = "red", mid = "white") +
theme_pander() +
ggtitle(paste(sub, ": Functional Connectivity, Standard Correlations)", sep="")) +
xlab("ROIs") +
ylab("ROIs")
dev.off()
write.table(R, col.names = T,
row.names = T,
file = paste(sub, "R.txt", sep="/"))
}
filenames <- paste("region_",
sprintf("%03d", power2011$ROI),
"_network_",
sprintf("%03d", max(0, power2011$Network)),
".txt",
sep="")
for (sub in dir()[grep("sub-*", dir())]) {
roidata <- NULL
print(sub)
for (roi in power2011$ROI) {
#print(roi)
network <- power2011 %>%
filter(ROI == roi) %>%
dplyr::select(Network) %>%
as.numeric()
network_name <- power2011 %>%
filter(ROI == roi) %>%
dplyr::select(NetworkName) %>%
as.character()
file_name <- paste("region_",
sprintf("%03d", roi),
"_network_",
sprintf("%02d", max(0, network)),
".txt",
sep="")
#mat <- t(read.table(paste(sub, "func", file_name, sep="/")))
#pc1 <- prcomp(mat)  #PCA
#pc1 <- pc1$x[,1]    # first PC
mat <- colMeans(read.table(paste(sub, "func", file_name, sep="/")))
pc1 <- mat
table <- tibble(subject = sub,
scan = 1:209,
timeseries = pc1,
roi = roi,
network = network,
network_name = network_name)
if (is.null(roidata)) {
roidata <- table
} else {
roidata %<>% bind_rows(table)
}
}
# Pivot long data format into wide data
wroidata <- roidata %>% pivot_wider(id_cols = scan,
names_from = roi,
values_from = timeseries)
X  <- as.matrix(wroidata[,2:265])/1000
PR <- pcor(X)$estimate
R  <- cor(X)
# Generate matrices:
# The partial correlation matrix
long_pr <- melt(PR)
#pdf(paste(sub, "fc_pcorr.pdf", sep="/"))
ggplot(long_pr, aes(x=Var1, y=Var2)) +
geom_raster(aes(fill=value)) +
scale_fill_gradient2(limits=c(-1,1),
low = "blue",
high = "red",
mid = "white") +
theme_pander() +
ggtitle(paste(sub, ": Functional Connectivity (Partial Correlations)", sep="")) +
xlab("ROIs") +
ylab("ROIs")
#dev.off()
ggsave(paste(sub, "fc_pcorr.pdf", sep="/"))
write.table(PR, col.names = T,
row.names = T,
file = paste(sub, "PR.txt", sep="/"))
# The standard correlation matrix
long_r <- melt(R)
#pdf(paste(sub, "fc_corr.pdf", sep="/"))
ggplot(long_r, aes(x=Var1, y=Var2)) +
geom_raster(aes(fill=value)) +
scale_fill_gradient2(limits=c(-1,1), low = "blue", high = "red", mid = "white") +
theme_pander() +
ggtitle(paste(sub, ": Functional Connectivity, Standard Correlations)", sep="")) +
xlab("ROIs") +
ylab("ROIs")
#dev.off()
ggsave(paste(sub, "fc_corr.pdf", sep="/"))
write.table(R, col.names = T,
row.names = T,
file = paste(sub, "R.txt", sep="/"))
}
M <- read.table("sub-006/PR.txt")
M
dim(M)
colnames(M)
rownames(M)
library(pracma)
install.packages("pracma")
library(pracma)
Reshape(M, 264*264, 1)
dim(M)
Reshape(M, 264^2, 1)
Reshape(a = M, n = 264**2, m=1)
size(M)
Reshape(a = M, n =1)
z<-Reshape(a = M, n =1)
length(z)
dim(z)
z<-Reshape(a = M, m =1)
z<-Reshape(a = M, n = 264**2)
z<-Reshape(M, n = 264**2)
M
length(M)
dim(M)
array(M)
aM<-array(M)
Reshape(aM, n=1)
Reshape(aM, n=1, m=264**2)
as.vector(M)
as_vector(M)
as.vector(M)
as_vector(M)
v<-as_vector(M)
M[,1]
M[,1] = V[1:264]
M[,1] == v[1:264]
M[,2] == v[265:(264*2)]
M[2,] == v[265:(264*2)]
View(M)
M
M[1,1]
M[2,1]
M[,1]
M[,1] == M[,1]
M[1,] == v{1:264}
M[1,] == v[1:264]
M[,1] == v[1:264]
v[1:264]
v[1:20]
v[10]
v[264]
v[50]
v[264]
M[1,]
M[1,] == M[,1]
M[1,2] == M[2,1]
M[1,2]
M[2,1]
M[1,2] == M[2,1]
M[1,] - M[,1]
N<-round(M, digits=6)
N
N[,1] == N[,1]
cols <- outer(power2011$ROI, power2011$ROI, function(x, y) {paste(x, y, sep="-")})
cols
cols %<>% as_vector
cols
cols %<>% as.vector
cols
cols <- outer(power2011$ROI, power2011$ROI, function(x, y) {paste(x, y, sep="-")})
cols
cols[,1]
cols[1,]
View(cols)
cols[1,]
cols[,1]
C <- as.vector(cols)
C[1:264]
cols <- outer(power2011$ROI, power2011$ROI, function(x, y) {paste(x, y, sep="-")})
cols %<>% as.vector
cols[1:264]
nets <- outer(power2011$Network, power2011$Network, function(x, y) {paste(x, y, sep="-")})
nets %<>% as.vector
nets
nets <- outer(power2011$Network, power2011$Network, function(x, y) {paste(max(0, x), max(0, y), sep="-")})
nets <- outer(power2011$Network, power2011$Network, function(x, y) {paste(max(0, x), max(0, y), sep="-")})
nets <- outer(power2011$Network, power2011$Network, function(x, y) {paste(x, y, sep="-")})
nets %<>% as.vector
nets
unique(nets)
length(unique(nets))
sqrt(196)
n <- length(grep("sub-*", dir()))
n
n <- length(grep("sub-*", dir()))
X <- matrix(data = rep(0, length(cols)*n), nrow =  n)
dim(X)
n <- length(grep("sub-*", dir()))
X <- matrix(data = rep(0, length(cols)*n), nrow =  n)
X <- NULL
j <- 1
for (sub in dir()[grep("sub-*", dir())]) {
M <- read.table(paste(sub, "PR.txt"))
v <- as_vector(M)  # v spreads M column-wise. M is symmetrical, so it should not matter, but better not risk it
X[j,] <- v
j <- j + 1
}
cols <- outer(power2011$ROI, power2011$ROI, function(x, y) {paste(x, y, sep="-")})
cols %<>% as.vector
nets <- outer(power2011$Network, power2011$Network, function(x, y) {paste(x, y, sep="-")})
nets %<>% as.vector
n <- length(grep("sub-*", dir()))
X <- matrix(data = rep(0, length(cols)*n), nrow =  n)
X <- NULL
j <- 1
for (sub in dir()[grep("sub-*", dir())]) {
M <- read.table(paste(sub, "PR.txt", sep="/"))
v <- as_vector(M)  # v spreads M column-wise. M is symmetrical, so it should not matter, but better not risk it
X[j,] <- v
j <- j + 1
}
dim(X)
cols <- outer(power2011$ROI, power2011$ROI, function(x, y) {paste(x, y, sep="-")})
cols %<>% as.vector
nets <- outer(power2011$Network, power2011$Network, function(x, y) {paste(x, y, sep="-")})
nets %<>% as.vector
n <- length(grep("sub-*", dir()))
X <- matrix(data = rep(0, length(cols)*n), nrow =  n)
#X <- NULL
j <- 1
for (sub in dir()[grep("sub-*", dir())]) {
M <- read.table(paste(sub, "PR.txt", sep="/"))
v <- as_vector(M)  # v spreads M column-wise. M is symmetrical, so it should not matter, but better not risk it
X[j,] <- v
j <- j + 1
}
dim(X)
X
X[45,890]
X[45:50,890:900]
v
2:2:16
2:16
2:16:2
outer(1:264, 1:264, function(x,y){x <y})
length(v)
c<-outer(1:264, 1:264, function(x,y){x <y})
c
c<-as.vector(c)
c
v
length(v[c])
length(c)
length(nets[c])
length(unique(nets[c]))
unique(nets)
length(nets[c])
unique(nets)
unique(nets[c])
order <- tibble(index = 1:264**2, networks = networks, censor = censor, cols = cols)
order <- tibble(index = 1:264**2, networks = nets, censor = censor, cols = cols)
censor <- outer(power2011$ROI, power2011$ROI, function(x, y) {x < y})
order <- tibble(index = 1:264**2, networks = nets, censor = censor, cols = cols)
order <- tibble(index = 1:(264**2), networks = nets, censor = censor, cols = cols)
n(nets)
order <- tibble(index = 1:length(nets), networks = nets, censor = censor, cols = cols)
length(nets)
length(censor)
length(cols)
length(1:length(cols))
order <- tibble(index = 1:length(nets), networks = nets, censor = censor, cols = cols)
I <- 1:length(nets)
order <- tibble(index = I, networks = nets, censor = censor, cols = cols)
order <- tibble(index = I, networks = nets, censor = censor, connections = cols)
length(censor)
order <- tibble(index = I, networks = nets, keep = censor, connections = cols)
length(I)
order <- tibble(networks = nets, keep = censor, connections = cols)
order <- tibble(networks = nets, connections = cols)
order <- tibble(index = I, networks = nets, connections = cols)
censor <- outer(power2011$ROI, power2011$ROI, function(x, y) {x < y})
I <- 1:length(nets)
order <- tibble(index = I, networks = nets, connections = cols)
order <- tibble(index = 1:length(nets), networks = nets, connections = cols)
order <- tibble(index = 1:length(nets), networks = nets, connections = cols)
order <- tibble(index = 1:length(nets), networks = nets, connections = cols, keep = censor)
order <- tibble(index = 1:length(nets), networks = nets, connections = cols)
order
order <- tibble(index = 1:length(nets), networks = nets, connections = cols)
order$censor <- censor
dim(censor)
censor <- outer(power2011$ROI, power2011$ROI, function(x, y) {x < y}) %>% as.vector()
dim(censor)
order <- tibble(index = 1:length(nets), networks = nets, connections = cols, censor=censor)
order %<>% order_by(network)
order %<>% arrange(network)
View(order)
order %<>% arrange(network, index)
View(order)
order %>% arrange(network, index)
order %>% arrange(connections, index)
order %>% arrange(network, index)
View(order)
order %>% arrange(networks, index)
order <- tibble(index = 1:length(nets), network = nets, connection = cols, censor=censor)
order %<>% arrange(network)
View(order)
I <- order %>%
filter(censor == TRUE) %>%
select(index)
I <- order %>%
filter(censor == TRUE) %>%
dplyr::select(index)
I
G <- order %>%
filter(censor == TRUE) %>%
dplyr::select(network)
G
unique(G)
nets <- outer(power2011$Network, power2011$Network, function(x, y) {paste(min(x, y), max(x, y), sep="-")})
net_name <- function(x, y) {
paste(min(x, y), max(x, y), sep="-")
}
vnet_name <- Vectorize(net_name)
nets <- outer(power2011$Network, power2011$Network, vnet_name)
nets %<>% as.vector
nets
nets <- outer(power2011$Network, power2011$Network, vnet_name)
View(nets)
nets %<>% as.vector
censor <- outer(power2011$ROI, power2011$ROI, function(x, y) {x < y}) %>% as.vector()
order <- tibble(index = 1:length(nets), network = nets, connection = cols, censor=censor)
order %<>% arrange(network)
I <- order %>%
filter(censor == TRUE) %>%
dplyr::select(index)
G <- order %>%
filter(censor == TRUE) %>%
dplyr::select(network)
G
unique(G$network)
length(unique(G$network))
as_factor(G)
as_numeric(as_factor(G))
as.numeric(as_factor(G))
as.double(as_factor(G))
as_factor(G)
as_vector(as_factor(G))
as_numeric(as_vector(as_factor(G)))
levels(as_factor(G))
?levels
levels(G)
levels(as_factor(G))
levels(as_factor(as.vector(G)))
I
X[I]
as_vector(I)
X[as_vector(I)]
dim(X[as_vector(I)])
dim(X[c(1,2)])
X[c(1,2)]
dim(X[,c(I)])
dim(X[,as_vector(I)])
dim(X[,as_vector(I)[1]])
dim(X[,as_vector(I)[1:2]])
G
as.vector(G)
as.vector(G)
levels(as.vector(G))
levels(G)
as.numeric(factor(G))
as.numeric(G)
G
as.numeric(factor(as.vector(G)))
levels(as.vector(G))
levels(factor(G))
values(factor(G))
value(factor(G))
levels(c("a", "b", "c")
)
levels(c("a", "b", "c"))
levels(factor(c("a", "b", "c")))
levels(factor(c("a", "b", "c", "a")))
as.numeric(factor(c("a", "b", "c", "a")))
as.numeric(factor(G))
G
as.numeric(factor(G$network))
as.numeric(G$network)
